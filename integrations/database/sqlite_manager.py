"""SQLite manager used for persisting messages and conversations."""

from __future__ import annotations

import sqlite3
from typing import Any, Dict, Optional


class SWAILiteManager:
    """Lightweight wrapper around :mod:`sqlite3`.

    Besides persisting messages produced by Layer 1, this manager also
    stores conversations generated by Layer 2 of the pipeline.
    """

    def __init__(self, db_path: str) -> None:
        self.db_path = db_path
        self.conn = sqlite3.connect(self.db_path)
        self.conn.row_factory = sqlite3.Row
        self._ensure_tables()

    # ------------------------------------------------------------------
    # Schema management
    # ------------------------------------------------------------------
    def _ensure_tables(self) -> None:
        """Create required tables if they do not exist."""
        with self.conn:
            self.conn.execute(
                """
                CREATE TABLE IF NOT EXISTS messages (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    message_id TEXT UNIQUE,
                    sender_phone TEXT,
                    receiver_phone TEXT,
                    sender_type TEXT,
                    content TEXT,
                    timestamp TEXT
                )
                """
            )

            self.conn.execute(
                """
                CREATE TABLE IF NOT EXISTS conversations (
                    conversation_id TEXT PRIMARY KEY,
                    lead_phone TEXT,
                    secretary_phone TEXT,
                    start_time TEXT,
                    message_count INTEGER DEFAULT 0,
                    status TEXT DEFAULT 'active'
                )
                """
            )

            self.conn.execute(
                """
                CREATE TABLE IF NOT EXISTS conversation_messages (
                    conversation_id TEXT,
                    message_id TEXT UNIQUE,
                    FOREIGN KEY(conversation_id) REFERENCES conversations(conversation_id)
                )
                """
            )

    # ------------------------------------------------------------------
    # Messages interface
    # ------------------------------------------------------------------
    def store_message(self, message: Dict[str, Any], overwrite: bool = False) -> Optional[int]:
        """Store a formatted message into the database."""

        columns = (
            "message_id",
            "sender_phone",
            "receiver_phone",
            "sender_type",
            "content",
            "timestamp",
        )
        values = tuple(message.get(col) for col in columns)

        with self.conn:
            if overwrite:
                cursor = self.conn.execute(
                    """
                    INSERT INTO messages (message_id, sender_phone, receiver_phone, sender_type, content, timestamp)
                    VALUES (?, ?, ?, ?, ?, ?)
                    ON CONFLICT(message_id) DO UPDATE SET
                        sender_phone=excluded.sender_phone,
                        receiver_phone=excluded.receiver_phone,
                        sender_type=excluded.sender_type,
                        content=excluded.content,
                        timestamp=excluded.timestamp
                    """,
                    values,
                )
                return cursor.lastrowid

            cursor = self.conn.execute(
                """
                INSERT OR IGNORE INTO messages (message_id, sender_phone, receiver_phone, sender_type, content, timestamp)
                VALUES (?, ?, ?, ?, ?, ?)
                """,
                values,
            )

            if cursor.rowcount == 0:
                return None

            return cursor.lastrowid

    def get_message_by_id(self, message_id: str) -> Optional[Dict[str, Any]]:
        """Return a stored message given its ``message_id``."""

        cursor = self.conn.execute(
            "SELECT * FROM messages WHERE message_id = ?",
            (message_id,),
        )
        row = cursor.fetchone()
        return dict(row) if row else None

    # ------------------------------------------------------------------
    # Conversations interface
    # ------------------------------------------------------------------
    def get_conversation(self, conversation_id: str) -> Optional[Dict[str, Any]]:
        """Return a conversation record by its identifier."""
        cursor = self.conn.execute(
            "SELECT * FROM conversations WHERE conversation_id = ?",
            (conversation_id,),
        )
        row = cursor.fetchone()
        return dict(row) if row else None

    def record_conversation_message(
        self,
        conversation_id: str,
        message_id: str,
        lead_phone: str,
        secretary_phone: str,
        timestamp: str,
    ) -> Dict[str, Any]:
        """Associate a message with a conversation and update counters.

        The operation is idempotent: repeated calls with the same
        ``message_id`` will not increment ``message_count`` more than once.
        """

        with self.conn:
            # Ensure conversation exists
            self.conn.execute(
                """
                INSERT OR IGNORE INTO conversations (
                    conversation_id, lead_phone, secretary_phone, start_time, message_count, status
                ) VALUES (?, ?, ?, ?, 0, 'active')
                """,
                (conversation_id, lead_phone, secretary_phone, timestamp),
            )

            row = self.conn.execute(
                "SELECT * FROM conversations WHERE conversation_id = ?",
                (conversation_id,),
            ).fetchone()

            if row["status"] == "completed":
                return dict(row)

            # Preserve earliest start time
            if row["start_time"] > timestamp:
                self.conn.execute(
                    "UPDATE conversations SET start_time = ? WHERE conversation_id = ?",
                    (timestamp, conversation_id),
                )

            cursor = self.conn.execute(
                """
                INSERT OR IGNORE INTO conversation_messages (conversation_id, message_id)
                VALUES (?, ?)
                """,
                (conversation_id, message_id),
            )

            if cursor.rowcount:
                self.conn.execute(
                    "UPDATE conversations SET message_count = message_count + 1 WHERE conversation_id = ?",
                    (conversation_id,),
                )

            row = self.conn.execute(
                "SELECT * FROM conversations WHERE conversation_id = ?",
                (conversation_id,),
            ).fetchone()

        return dict(row)

    def close(self) -> None:
        self.conn.close()

